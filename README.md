Структура практики 1-1:

График нагрузки:
1) Тип нагрузки (жилой сектор, освещение и т.д.) (LoadType).

  Поля:
  - тип нагрузки: str (lp_type)
  - величина нагрузки: float (lp)
  - cosf: float (cosf)

  Методы:
  - расчет полной мощности (apparent_lp)
  - расчет реактивной мощности (reactive_lp)

2) Суммарная нагрузка - массив типов нагрузки (TotalLoad). 

  Поля:
  - нагрузка: list[LoadType] (массив типов нагрузки) (load_list)

  Методы:
  - суммарная активная мощность нагрузки (total_active_lp)
  - суммарная реактивная мощность нагрузки (total_reactive_lp)
  - суммарная полная мощность нагрузки (total_apparent_lp)

3) График нагрузки HourlyDemand

 Нужно сделать так, чтобы можно было вызвать так:
 HourlyDemand() - это годовой график потребления
 HourlyDemand("Январь") - месячный график потребления
 HourlyDemand("Январь", 1) - график потребления за 1 Января

 Поля:
  - суточный график нагрузки, %: list (daily_load_schedule)
    (с проверкой на поступающий массив:
     если 12 значений, то это 12 часов, и мы дублируем значения,
     если 24 значения, то оставляем неизменным)
  - коэффициенты сезонности по месяцам: dict (месяц: коэф.сез.) (season_coeffs)

  Методы:
  - сезонный максимум по месяцам (season_max_lp):
    для каждого месяца total_active_lp * season_coeffs[месяц]
    возвращает dict (месяц: активная мощность с учетом sc)
  - нормализация формы суточного графика нагрузки (normalize_dls):
    daily_load_schedule[i]/100
    возвращает массив длиной 24
  - почасовая мощность (year_hourly_demand):
    здесь есть словарь (seasons) (месяц: число дней в месяце) (без учета високосности);
    массив year_hourly_demand собирается так:
      берется значение из season_max_lp, на него умножаются все значения копии
      normalize_dls, полученный массив протягивается на seasons[месяц]
      и добавляется к результирующему массиву, и так 12 раз (месяцев в году)

Генерирующие мощности:
1) ДЭУ (DieselUnit)

 Поля:
 - наименование генератора (name: str)
 - номинальная активная мощность (rated_active_power: float)
 - номинальная полная мощность (rated_apparent_power: float)
 - пиковая активная мощность (peak_active_power: float)
 - количество фаз (number_of_phases: int)
 - номинальное напряжение (rated_voltage: float)
 - удельный расход топлива (spec_fuel_cons: float)
 - минимальная допустимая загрузка (40% от rated_active_power)
 - коэффициент потребления топлива на ХХ (coeff_fc = 0.3: float)
 - загрузка в данный момент времени (active_power=0: float)
 - ограничение на минимальную рекомендуемую мощность (min_active_power: float)

 Методы:
 - фактический удельный расход топлива (actual_spec_fuel_cons):
   actual_spec_fuel_cons = coeff_fc*spec_fuel_cons + (1-coeff_fc)*spec_fuel_cons*(active_power/rated_active_power)

2) ДЭС (DieselGenerator)

 Поля:
 - наименование станции (name: str)
 - список ДЭУ (units: list=[])
 - вид компоновки (assembly_type: str)
 - установленная мощность (rated_apparent_power: float, как сумма мощностей ДЭУ)

 Методы:
 - суммарное потребление топлива (total_fuel_cons):
   total_fuel_cons = sum(unit.actual_spec_fuel_cons() * unit.active_power for unit in units)
 - автокомпоновка (auto_assembly_dg):
   принимает максимальную нагрузку (total_apparent_lp).
   берем базу ДЭУ, смотрим на вид компоновки ДЭС:
   1) если assembly_type="2x50":
   берем 2 ДЭУ каждый по 50% от total_apparent_lp
   2) если assembly_type="2x40+20":
   берем 2 ДЭУ по 40% от total_apparent_lp и 1 ДЭУ на 20% от total_apparent_lp
   добавляем компоновку в units

3) ГЭС (HydroPowerPlant)

 Поля:
 - наименование генератора (name: str)
 - номинальная активная мощность (rated_active_power: float)
 - номинальная полная мощность (rated_apparent_power: float)
 - номинальное напряжение (rated_voltage: float)
 - загрузка в данный момент времени (active_power=0: float)

Дополнительное оборудование:

1) АКБ (BES):

 Поля:
  - наименование (name: str)
  - номинальное напряжение (rated_voltage: float)
  - номинальная емкость (rated_capacity: float) 
  - удельная энергия (specific_energy: float) 
  - масса (weight: float)
  - цена (price: float)
  - габариты (длина, ширина, высота) (geometry: tuple[float, float, float])

2) Банк АКБ (BESbank):

 Поля:
 - наименование (name: str)
 - список АКБ (units: list=[])
 - установленная активная мощность (rated_active_power: float)
    как сумма мощностей АКБ, постинитом
 - номинальное напряжение (rated_voltage: float)
    при последовательном соединении - как сумма напряжений АКБ
    при параллельном соединении - как напряжение АКБ
 - количество веток АКБ (bes_branches: int (default = 1))

 Методы:
 - максимальная энергия заряда банка АКБ:
    берется график нагрузки за год, находится день, 
    при котором разница мощности МГЭС и нагрузки, покрываемой МГЭС, минимальна.
    Причем в эту разность входит только нагрузка, которую гарантированно 
    может покрыть МГЭС. Т.е. суммируем разности за каждый час такого дня.

Диспетчер:
1) Фабрика алгоритмов оптимизации
2) Такой-то алгоритм:

Алгоритм:

1) берется нагрузка в данный момент времени за вычетом
    мощности МГЭС
2) смотрим располагаемую мощность:
- если нагрузка меньше мощности МГЭС,
    заряжаем батарею АКБ на разность мощности МГЭС и нагрузки
- если нагрузка больше мощности МГЭС:
    - если накопленная мощность батареи АКБ + мощность МГЭС >= нагрузки,
    то покрываем нагрузку за счет этой суммы мощностей 
    (соблюдая баланс, т.е. регулируя выдаваемую мощность батареи АКБ);
    - если накопленная мощность батареи АКБ + мощность МГЭС < нагрузки,
    включаем ДЭС на 40-100% своей мощности. Если эта мощность больше нагрузки,
    заряжаем батарею АКБ избытком.
    - если мощность ДЭС + мощность МГЭС < нагрузки, включаем батарею АКБ.
    - если накопленная мощность батареи АКБ + мощность МГЭС + мощность ДЭС < нагрузки: выдаем ошибку